

lets start with plain structure: single bot.py in root; Dockerfile, github actions for building and registry; install2k8s.py later; all config from evniron:
  TG2SITE_CONF_CONTENT, TG2SITE_SECRETS_PATH - json format; terse style: heavy on comprehensions, construstion, minimal mutations;



mention too: methods on classes are rarely needed; choose comprehensions over loops with mutating operations (append, extend, `=`); choose simple construction (not comprehension) if lists are constant;








https://<TOKEN>@github.com/<owner>/<repo>.git



https://github.com/settings/personal-access-tokens
choose repo
permissions → Contents → Read and write


## Scala variants

- `bot.sc`: Ammonite-based script (Scala 2 runtime, minimal dependencies)
- `bot.scala-cli.sc`: Scala 3 Scala-CLI script (inline `using` deps, runnable via `scala-cli shebang`)

Dockerfiles include intentional comments that explain staging/caching choices—keep them unless directions change.

## Мысли

Я тут ради интереса реализую одно и то же на разных технологиях.
Созерцаю выразительность языков.
Пока получается так - логика приложения (без учета совсем общих хелперов), строк:
- scala, python - 50
- java - 70
- go - 90

В go получается многословней - нету тернарного оператора (1) и вывода типов у лямбд (2).

(1)
`var a = c ? b() : d();`
vs
```
var a AComplexType
if c {
    a = b()
} else {
    a = d()
}
```
Реально оно вынесется в функцию, чтобы не засорять обзор: `a := getA(...`

(2)
`var a = f(k -> g(j,k));`
vs
`a := f(func(k AComplexType) AComplexType { return g(j,k) })`

Это вещи, которые нельзя вынести в библиотеку (как тот же http server) и вызвать парой строк.

###

Сразу скажу, что систем, на которых работают одновременно тысячи человек, не делал.
Много на скриптовых языках писал.
И даже если функциональщик, то не совсем упоротый.

Для меня важно, сколько полезной информации можно одним взглядом охватить на экране.
Тогда мой "визуальный процессор" лучше задействован. Очень субъективно.
Код делю на прикладную и системную (обобщенную) часть.

Про ошибки (исключения, паника):
Ну, у конкретных функциональщиков исключения тоже не по канонам.
Что значит, "ошибки не выводишь"?
Я думаю для подобной программы от паники одни плюсы:
- не захламляется обзор алгоритма
- программа честно и громко падает, рассказывает где, супервизор ее переподнимает
- мы получаем сигнал, смотрим лог, и при необходимости дорабатываем
  Было бы хуже, если бы программа скромно гасила ошибки и не выполняла необходимого.
  У меня ощущение, что если пойти по пути "паника плохо" и пройти не до конца, то оно этим и кончится.
  Так что, совет ленивым разрабам - честно паникуйте, это так же просто, как не обрабатывать ошибки, но гораздо менее вредно.
  И ловить (recover) нужно тоже не просто так, а понимая, что иначе в конкретном случае будет чем-то хуже.
  И что написанную по любым правилам программу завалит на середине oom-killer или сбой железа.
  Go дает возможность подходить к вопросу по разному.
  Или я упускаю какую-то специфику?

Про неизменяемость:
Я часто работаю в многопоточной среде - много потоков работают с общими данными.
Надежней всего - сделать данные неизменяемыми.
Структуры заполняются на системном уровне, в конструкторах.
После этого в прикладном коде менять их нельзя. Совсем.
В скале есть для такого средства на уровне синтаксиса и коллекций (и еще линтер сторонний).
В го я пытался нащупать что-то похоже (хотя для этого бота оно не обязательно).
Сознательно использовал в прикладном коде только `:=`, вынося `=` и `append` в системные конструкторы.
Хотя `a, b :=` всё равно дырявый, одну из них можно спокойно поменять повторно.
Можно было бы еще делать всё приватным (но только для другого пакеджа) с геттерами.
Если слать через канал простую структуру - она копируется, а чуть сложнее - нужны указатели.
Вот как люди с этим живут?
